var searchIndex = {};
searchIndex["rowdy"] = {"doc":"Build Status Dependency Status Crates.io Repository Documentation","items":[[4,"JsonValue","rowdy","Represents any valid JSON value.",null,null],[13,"Null","","Represents a JSON null value.",0,null],[13,"Bool","","Represents a JSON boolean.",0,null],[13,"Number","","Represents a JSON number, whether integer or floating point.",0,null],[13,"String","","Represents a JSON string.",0,null],[13,"Array","","Represents a JSON array.",0,null],[13,"Object","","Represents a JSON object.",0,null],[3,"JsonMap","","Represents a JSON key/value type.",null,null],[3,"Url","","Wrapper around `hyper::Url` with `Serialize` and `Deserialize` implemented",null,null],[3,"Configuration","","Application configuration. Usually deserialized from JSON for use.",null,null],[12,"token","","Token configuration. See the type documentation for deserialization examples",1,null],[12,"basic_authenticator","","The configuration for the authenticator that will handle HTTP Basic Authentication.",1,null],[4,"Error","","Top level error enum",null,null],[13,"GenericError","","A generic/unknown error",2,null],[13,"BadRequest","","A bad request resulting from bad request parameters/headers",2,null],[13,"Auth","","Authentication error",2,null],[13,"CORS","","CORS error",2,null],[13,"Token","","Token Error",2,null],[13,"IOError","","IO errors",2,null],[13,"LaunchError","","An error launcing Rocket",2,null],[13,"UnsupportedOperation","","Unsupported operation",2,null],[4,"ByteSequence","","A sequence of bytes, either as an array of unsigned 8 bit integers, or a string which will be treated as UTF-8. This enum is (de)serialized `untagged`.",null,null],[13,"String","","A string which will be converted to UTF-8 and then to bytes.",3,null],[13,"Bytes","","A sequence of unsigned 8 bits integers which will be treated as bytes.",3,null],[5,"routes","","Return routes provided by rowdy",null,{"inputs":[],"output":{"name":"vec"}}],[5,"launch","","Convenience function to ignite and launch rowdy. This function will never return",null,{"inputs":[{"name":"configuration"}],"output":{"name":"launcherror"}}],[0,"auth","","Authentication module, including traits for identity provider and `Responder`s for authentication.",null,null],[3,"NoOp","rowdy::auth","A \"no-op\" authenticator that lets everything through. DO NOT USE THIS IN PRODUCTION.",null,null],[3,"NoOpConfiguration","","Configuration for the `no-op` authenticator. Nothing to configure.",null,null],[3,"LdapAuthenticator","","LDAP based authenticator",null,null],[12,"address","","Location of the LDAP server",4,null],[12,"bind_dn","","The user that we will bind to LDAP to search for users",4,null],[12,"bind_password","","The password that we will use to bind to LDAP to search for users",4,null],[12,"search_base","","Base to use when searching for user. `{account}` is expanded to the user's account. Search filters MUST be escaped according to RFC 4515.",4,null],[12,"search_filter","","Filter to use when searching for user. `{account}` is expanded to the user's account. Search filters MUST be escaped according to RFC 4515.",4,null],[12,"include_attributes","","List of attributes from the LDAP Search Result Entry to be included in the JWT. The values will be placed under the `attributes_namespace` key in the JWT. Missing keys are silently ignored.",4,null],[12,"attributes_namespace","","Namespace or Key in the returned JSON Web Token to return `include_attributes` attributes in. See the documentation for the `include_attributes` for more information.",4,null],[12,"subject_attribute","","The LDAP attribute to be used as the \"subject\" of the JWT token issued. By default, the `dn` attribute will be used. Another common attribute would be `cn`.",4,null],[3,"Authorization","","`Authorization` HTTP Request Header",null,null],[12,"0","","",5,null],[3,"AuthenticationResult","","Result from a successful authentication operation",null,null],[12,"subject","","The subject of the authentication",6,null],[12,"private_claims","","Additional private claims to be included in the authentication token, if any",6,null],[12,"refresh_payload","","The payload to be included in a Refresh token, if any",6,null],[4,"Error","","Authentication errors",null,null],[13,"AuthenticationFailure","","Authentication was attempted successfully, but failed because of bad user credentials, or other reasons.",7,null],[13,"GenericError","","A generic error",7,null],[13,"HyperError","","An error due to `hyper`, such as header parsing failure",7,null],[13,"MissingAuthorization","","The `Authorization` HTTP request header was required but was missing. This variant will `respond` with the appropriate `WWW-Authenticate` header.",7,null],[12,"realm","rowdy::auth::Error","The HTTP basic authentication realm",7,null],[5,"missing_authorization","rowdy::auth","Convenience function to respond with a missing authorization error",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[0,"util","","Utility functions to aid in managing users",null,null],[5,"hash_password_digest","rowdy::auth::util","Given a password and a salt, generate an argon2i hash 32 bytes in length",null,null],[5,"generate_salt","","Generate a new random salt based on the configured salt length",null,{"inputs":[{"name":"usize"}],"output":{"name":"result"}}],[5,"hex_dump","","Dump a bunch of bytes as a hexadecimal string",null,null],[11,"fmt","rowdy::auth","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"authenticate","","",8,{"inputs":[{"name":"self"},{"name":"authorization"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate_refresh_token","","",8,{"inputs":[{"name":"self"},{"name":"jsonvalue"}],"output":{"name":"result"}}],[11,"authenticate","","",8,{"inputs":[{"name":"self"},{"name":"authorization"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate_refresh_token","","",8,{"inputs":[{"name":"self"},{"name":"jsonvalue"}],"output":{"name":"result"}}],[11,"authenticate","","",8,{"inputs":[{"name":"self"},{"name":"authorization"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate_refresh_token","","",8,{"inputs":[{"name":"self"},{"name":"jsonvalue"}],"output":{"name":"result"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"make_authenticator","","",9,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"simple","","Simple authenticator module",null,null],[3,"SimpleAuthenticator","rowdy::auth::simple","A simple authenticator that uses a CSV backed user database. DO NOT USE THIS IN PRODUCTION",null,null],[3,"SimpleAuthenticatorConfiguration","","(De)Serializable configuration for `SimpleAuthenticator`. This struct should be included in the base `Configuration`. # Examples `json { \"csv_path\": \"test/fixtures/users.csv\", \"has_headers\": false, \"delimiter\": \" \" }`",null,null],[12,"csv_path","","Path to the CSV database, in the format described by `SimpleAuthenticator`. This should be relative to the working directory, or an absolute path",10,null],[12,"has_headers","","Whether the CSV file has a header row or not. Defaults to `false`.",10,null],[12,"delimiter","","The delimiter char. By default, this is ','. Because of the limitation of the `CSV` crate which elects to only allow delimiters with one byte, the `char` will be truncated to only one byte. This means you should only use delimiters that are ASCII.",10,null],[5,"hash_passwords","","Convenience function to hash passwords from some users and provided passwords The salt length must be between 8 and 2^32 - 1 bytes.",null,{"inputs":[{"name":"hashmap"},{"name":"usize"}],"output":{"name":"result"}}],[5,"write_csv","","Convenience function to write `Users` to a Writer",null,{"inputs":[{"name":"users"},{"name":"w"}],"output":{"name":"result"}}],[6,"Users","","Typedef for the internal representation of a users database. The keys are the usernames, and the values are a tuple of the password hash and salt.",null,null],[11,"new","","Create a new `SimpleAuthenticator` with the provided a CSV Reader.",11,{"inputs":[{"name":"reader"}],"output":{"name":"result"}}],[11,"with_csv_file","","Create a new `SimpleAuthenticator` with a path to a CSV file.",11,{"inputs":[{"name":"str"},{"name":"bool"},{"name":"u8"}],"output":{"name":"result"}}],[11,"hash_password","","Hash a password with the salt. See struct level documentation for the algorithm used.",11,null],[11,"verify","","Verify that some user with the provided password exists in the CSV database, and the password is correct.",11,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate","","",11,{"inputs":[{"name":"self"},{"name":"authorization"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate_refresh_token","","",11,{"inputs":[{"name":"self"},{"name":"jsonvalue"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"simpleauthenticatorconfiguration"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"simpleauthenticatorconfiguration"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"make_authenticator","","",10,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"from","rowdy","",2,{"inputs":[{"name":"fmterror"}],"output":{"name":"error"}}],[11,"clone","rowdy::auth","",4,{"inputs":[{"name":"self"}],"output":{"name":"ldapauthenticator"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"ldapauthenticator"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"ldapauthenticator"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"connect","","Connects to the LDAP server",4,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"bind","","Bind a connection to some dn",4,{"inputs":[{"name":"self"},{"name":"ldapconn"},{"name":"str"},{"name":"str"}],"output":{"name":"result"}}],[11,"verify","","Authenticate the user with the username/password",4,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate","","",4,{"inputs":[{"name":"self"},{"name":"authorization"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate_refresh_token","","",4,{"inputs":[{"name":"self"},{"name":"jsonvalue"}],"output":{"name":"result"}}],[11,"make_authenticator","","",4,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[6,"Scheme","","Re-exported [`hyper::header::Scheme`]",null,null],[6,"Basic","","Re-exported [`hyper::header::Basic`].",null,null],[6,"Bearer","","Re-exported [`hyper::header::Bearer`].",null,null],[6,"BasicAuthenticator","","A typedef for an `Authenticator` trait object that requires HTTP Basic authentication",null,null],[6,"BearerAuthenticator","","A typedef for an `Authenticator` trait object that requires Bearer authentication.",null,null],[6,"StringAuthenticator","","A typedef for an `Authenticator` trait object that uses an arbitrary string",null,null],[8,"Authenticator","","Authenticator trait to be implemented by identity provider (idp) adapters to provide authentication. Each idp may support all the schemes supported, or just one.",null,null],[10,"authenticate","","Verify the credentials provided in the headers with the authenticator for the initial issuing of Access Tokens.",12,{"inputs":[{"name":"self"},{"name":"authorization"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate_refresh_token","","Verify the credentials provided with the refresh token payload, if supported by the authenticator.",12,{"inputs":[{"name":"self"},{"name":"jsonvalue"}],"output":{"name":"result"}}],[11,"prepare_authentication_response","","Prepare a response to an authentication request by first verifying credentials. If validation fails, will return an `Err` with the response to be sent. Otherwise, the unwrapped authentication result will be returned in an `Ok`. This function will also check that the authenticator behaves correctly by checking that it does not return a refresh token payload when it is not requested for",12,{"inputs":[{"name":"self"},{"name":"authorization"},{"name":"bool"}],"output":{"name":"result"}}],[11,"prepare_refresh_response","","Prepare a response to a refresh request by first verifying the refresh payload.",12,{"inputs":[{"name":"self"},{"name":"jsonvalue"}],"output":{"name":"result"}}],[8,"AuthenticatorConfiguration","","Configuration for the associated type `Authenticator`. [`rowdy::Configuration`] expects its `authenticator` field to implement this trait.",null,null],[16,"Authenticator","","The `Authenticator` type this configuration is associated with",13,null],[10,"make_authenticator","","Using the configuration struct, create a new `Authenticator`.",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",7,{"inputs":[{"name":"string"}],"output":{"name":"error"}}],[11,"from","","",7,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"description","","",7,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",7,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"respond_to","","",7,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from_request","","",5,{"inputs":[{"name":"request"}],"output":{"name":"outcome"}}],[11,"new","","Create a new Authorization header",5,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"is_basic","","Convenience function to check if the Authorization is `Basic`",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_bearer","","Convenience function to check if the Authorization is `Bearer`",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_string","","Convenience function to check if the Authorization is `None`",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"username","","Convenience method to retrieve the username from a HTTP Basic Authorization request header",5,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"password","","Convenience method to retrieve the password from a HTTP Basic Authorization request header",5,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"token","","Convenience method to retrieve the token from a bearer Authorization request header.",5,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"string","","Convenience method to retrieve the token from an arbitrary Authorization request header.",5,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"deref","","",5,null],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"authenticationresult"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"authenticationresult"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"authenticationresult"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"serde_custom","rowdy","Custom serde serialization and deserialization.",null,null],[0,"duration","rowdy::serde_custom","Custom serializer and deserializer for `std::time::Duration`. Serializes to seconds, and deserializes from seconds.",null,null],[5,"serialize","rowdy::serde_custom::duration","Serialize a `Duration` into a `u64` representing the seconds",null,{"inputs":[{"name":"duration"},{"name":"s"}],"output":{"name":"result"}}],[5,"deserialize","","From a `u64`, deserialize into a `Duration` with the `u64` in seconds",null,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[0,"token","rowdy","Authentication token structs, and methods",null,null],[3,"Configuration","rowdy::token","Token configuration. Usually deserialized as part of [`rowdy::Configuration`] from JSON for use.",null,null],[12,"issuer","","The issuer of the token. Usually the URI of the authentication server. The issuer URI will also be used in the UUID generation of the tokens, and is also the `realm` for authentication purposes.",14,null],[12,"allowed_origins","","Origins that are allowed to issue CORS request. This is needed for browser access to the authentication server, but tools like `curl` do not obey nor enforce the CORS convention.",14,null],[12,"audience","","The audience intended for your tokens. The `service` request paremeter will be validated against this",14,null],[12,"signature_algorithm","","Defaults to `none`",14,null],[12,"secret","","Secrets for use in signing a JWT. This enum (de)serialized as an untagged enum variant.",14,null],[12,"expiry_duration","","Expiry duration of tokens, in seconds.",14,null],[12,"refresh_token","","Customise refresh token options. Set to `None` to disable refresh tokens",14,null],[3,"RefreshTokenConfiguration","","Configuration for Refresh Tokens",null,null],[12,"cek_algorithm","","Algorithm used to determine and/or encrypt the CEK",15,null],[12,"enc_algorithm","","Algorithm used to encrypt the content using the CEK",15,null],[12,"key","","Key used in determining the CEK, or directly encrypt the content depending on the `cek_algorithm`",15,null],[12,"expiry_duration","","Expiry duration of refresh tokens, in seconds.",15,null],[3,"RefreshToken","","A Refresh Token containing the payload (called refresh payload) used by an authenticator to issue new access tokens without needing the user to re-authenticate.",null,null],[3,"Token","","A token that will be serialized into JSON and passed to clients. This encapsulates a JSON Web Token or `JWT`. Clients will pass the encapsulated JWT to services that require it. The JWT should be considered opaque to clients. The `Token` struct contains enough information for the client to act on, including expiry times.",null,null],[12,"token","","Tne encapsulated JWT.",16,null],[12,"expires_in","","The duration from `issued_at` where the token will expire",16,null],[12,"issued_at","","Time the token was issued at",16,null],[12,"refresh_token","","Refresh token, if enabled and requested for",16,null],[3,"Keys","","Keys prepared in a form directly usable for cryptographic operations. This prevents us from having to repeatedly read keys from the file system.  Users should prepare the keys from `Configuration` using `Configuration::keys()` and then use this struct to retrieve keys from instead of the functions from `Secret`.",null,null],[12,"signing","","Key used to signed tokens",17,null],[12,"signature_verification","","Key used to verify token signatures",17,null],[12,"encryption","","Key used to encrypt tokens. Used if Refresh tokens are enabled.",17,null],[12,"decryption","","Key used to decrypt tokens. Used if Refresh tokens are enabled.",17,null],[4,"Error","","Token errors",null,null],[13,"TokenAlreadyEncoded","","Raised when attempting to encode an already encoded token",18,null],[13,"TokenAlreadyDecoded","","Raised when attempting to decode an already decoded token",18,null],[13,"TokenNotEncoded","","Raised when attempting to use a decoded token when an encoded one is expected",18,null],[13,"TokenNotDecoded","","Raised when attempting to use an encoded token when an decoded one is expected",18,null],[13,"NoRefreshToken","","Raised when attempting to perform an operation on the refresh token, but the refresh token is not present",18,null],[13,"RefreshTokenAlreadyEncrypted","","Raised when attempting to encrypt and sign an already encrypted and signed refresh token",18,null],[13,"RefreshTokenAlreadyDecrypted","","Raised when attempting to decrypt and verify an already decrypted and verified refresh token",18,null],[13,"RefreshTokenNotDecrypted","","Raised when attempting to use an encrypted refresh token when a decrypted one is expected",18,null],[13,"RefreshTokenNotEncrypted","","Raised when attempting to use an decrypted refresh token when a encrypted one is expected",18,null],[13,"InvalidService","","Raised when the service requested is not in the list of intended audiences",18,null],[13,"InvalidIssuer","","Raised when the issuer is invalid",18,null],[13,"InvalidAudience","","Raised when the audience is invalid",18,null],[13,"GenericError","","Generic Error",18,null],[13,"IOError","","IO Error when reading keys from files",18,null],[13,"JWTError","","Errors during token encoding/decoding",18,null],[13,"TokenSerializationError","","Errors during token serialization",18,null],[4,"Secret","","Secrets for use in signing and encrypting a JWT. This enum (de)serialized as an untagged enum variant.",null,null],[13,"None","","No secret -- used when no signature or encryption is required.",19,null],[13,"ByteSequence","","Secret for HMAC signing",19,null],[13,"Bytes","","Path to a file containing the byte sequence for HMAC signing or encryption key",19,null],[12,"path","rowdy::token::Secret","Path to the file containing the byte sequence for a HMAC signing or encryption key",19,null],[13,"RSAKeyPair","rowdy::token","DER RSA Key pair. See [`jwt::jws::Secret`] for more details.",19,null],[12,"rsa_private","rowdy::token::Secret","Path to DER encoded private key",19,null],[12,"rsa_public","","Path to DER encoded public key",19,null],[6,"TokenGetterCorsOptions","rowdy::token","A wrapper around `cors::Options` for options specific to the token retrival route",null,null],[6,"PrivateClaim","","Private claims that will be included in the JWT.",null,null],[6,"RefreshTokenPayload","","Convenient typedef for the type of the Refresh Token Payload. This is a signed JWS which contains a JWT Claims set.",null,null],[6,"RefreshTokenJWE","","Convenient typedef for the type of the encrypted JWE wrapping `RefreshTokenPayload`. This is a JWE which contains a JWS that contains a JWT Claims set.",null,null],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",18,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",18,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",18,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",18,{"inputs":[{"name":"string"}],"output":{"name":"error"}}],[11,"from","","",18,{"inputs":[{"name":"str"}],"output":{"name":"error"}}],[11,"description","","",18,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",18,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"respond_to","","",18,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"result"}}],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"configuration"}}],[11,"refresh_token_enabled","","Returns whether refresh tokens are enabled",14,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"refresh_token","","Convenience function to return a reference to the Refresh Token configuration.",14,{"inputs":[{"name":"self"}],"output":{"name":"refreshtokenconfiguration"}}],[11,"keys","","Prepare the keys for use with various cryptographic operations",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"refreshtokenconfiguration"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"refreshtoken"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",20,{"inputs":[{"name":"self"},{"name":"refreshtoken"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"self"},{"name":"refreshtoken"}],"output":{"name":"bool"}}],[11,"new_encrypted","","Create a new decrypted struct based on the Base64 encoded token string",20,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"unwrap","","Unwrap and consumes self, producing the wrapped JWE. You generally should not, and do not need to call this.",20,{"inputs":[{"name":"self"}],"output":{"name":"refreshtokenjwe"}}],[11,"encrypted","","Returns whether the refresh token is already encrypted and signed",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"decrypted","","Returns whether the refresh token is already decrypted and verified",20,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"encrypt","","Consumes self, and sign and encrypt the refresh token. If the Refresh Token is already encrypted, this will return an error",20,{"inputs":[{"name":"self"},{"name":"secret"},{"name":"jwk"}],"output":{"name":"result"}}],[11,"decrypt","","Consumes self, and decrypt and verify the signature of the refresh token If the refresh token is already decrypted, this will return an error",20,{"inputs":[{"name":"self"},{"name":"secret"},{"name":"jwk"},{"name":"signaturealgorithm"},{"name":"keymanagementalgorithm"},{"name":"contentencryptionalgorithm"}],"output":{"name":"result"}}],[11,"payload","","Retrieve a reference to the decrypted payload",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"validate","","Validate the times and claims of the refresh token",20,{"inputs":[{"name":"self"},{"name":"str"},{"name":"configuration"},{"name":"option"}],"output":{"name":"result"}}],[11,"to_string","","Convenience function to convert a decrypted payload to string",20,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"borrow","","",20,{"inputs":[{"name":"self"}],"output":{"name":"refreshtokenjwe"}}],[11,"from","","",20,{"inputs":[{"name":"refreshtokenjwe"}],"output":{"name":"self"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",16,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",16,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"with_configuration","","Based on the configuration, make a token for the subject, along with some private claims.",16,{"inputs":[{"name":"configuration"},{"name":"str"},{"name":"str"},{"name":"t"},{"name":"option"}],"output":{"name":"result"}}],[11,"encode","","Consumes self and encode the embedded JWT with signature. If the JWT is already encoded, this returns an error",16,{"inputs":[{"name":"self"},{"name":"secret"}],"output":{"name":"result"}}],[11,"decode","","Consumes self and decode the embedded JWT with signature verification If the JWT is already decoded, this returns an error",16,{"inputs":[{"name":"self"},{"name":"secret"},{"name":"signaturealgorithm"}],"output":{"name":"result"}}],[11,"is_decoded","","Returns whether the wrapped token is decoded and verified",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_encoded","","Returns whether the wrapped token is encoded and signed",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"registered_claims","","Convenience function to extract the registered claims from a decoded token",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"private_claims","","Conveneince function to extract the private claims from a decoded token",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"header","","Convenience function to extract the headers from a decoded token",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"encoded_token","","Convenience method to extract the encoded token",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"refresh_token","","Convenience method to obtain a reference to the refresh token",16,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"encrypt_refresh_token","","Consumes self, and encrypt and sign the embedded refresh token",16,{"inputs":[{"name":"self"},{"name":"secret"},{"name":"jwk"}],"output":{"name":"result"}}],[11,"decrypt_refresh_token","","Consumes self, and decrypt and verify the signature of the embedded refresh token",16,{"inputs":[{"name":"self"},{"name":"secret"},{"name":"jwk"},{"name":"signaturealgorithm"},{"name":"keymanagementalgorithm"},{"name":"contentencryptionalgorithm"}],"output":{"name":"result"}}],[11,"has_refresh_token","","Returns whether there is a refresh token",16,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"respond_to","","",16,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"result"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"secret"}}],[11,"default","","",19,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","rowdy","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",2,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",2,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",2,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",2,{"inputs":[{"name":"string"}],"output":{"name":"error"}}],[11,"from","","",2,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",2,{"inputs":[{"name":"launcherror"}],"output":{"name":"error"}}],[11,"description","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"respond_to","","",2,{"inputs":[{"name":"self"},{"name":"request"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"url"}}],[11,"eq","","",21,{"inputs":[{"name":"self"},{"name":"url"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"self"},{"name":"url"}],"output":{"name":"bool"}}],[11,"hash","","",21,null],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"deref","","",21,null],[11,"from_str","","",21,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"serialize","","",21,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",21,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bytesequence"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"bytesequence"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"bytesequence"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"as_bytes","","Returns the byte sequence.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"configuration"}}],[11,"ignite","","Ignites the rocket with various configuration objects, but does not mount any routes. Remember to mount routes and call `launch` on the returned Rocket object. See the struct documentation for an example.",1,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"get","","Index into a JSON array or map. A string index can be used to access a value in a map, and a usize index can be used to access an element of an array.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[11,"get_mut","","Mutably index into a JSON array or map. A string index can be used to access a value in a map, and a usize index can be used to access an element of an array.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"option"}}],[11,"is_object","","Returns true if the `Value` is an Object. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_object","","If the `Value` is an Object, returns the associated Map. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_object_mut","","If the `Value` is an Object, returns the associated mutable Map. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_array","","Returns true if the `Value` is an Array. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_array","","If the `Value` is an Array, returns the associated vector. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_array_mut","","If the `Value` is an Array, returns the associated mutable vector. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_string","","Returns true if the `Value` is a String. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_str","","If the `Value` is a String, returns the associated str. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_number","","Returns true if the `Value` is a Number. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_i64","","Returns true if the `Value` is an integer between `i64::MIN` and `i64::MAX`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_u64","","Returns true if the `Value` is an integer between zero and `u64::MAX`.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_f64","","Returns true if the `Value` is a number that can be represented by f64.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_i64","","If the `Value` is an integer, represent it as i64 if possible. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_u64","","If the `Value` is an integer, represent it as u64 if possible. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"as_f64","","If the `Value` is a number, represent it as f64 if possible. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_boolean","","Returns true if the `Value` is a Boolean. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_bool","","If the `Value` is a Boolean, returns the associated bool. Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"is_null","","Returns true if the `Value` is a Null. Returns false otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"as_null","","If the `Value` is a Null, returns (). Returns None otherwise.",0,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"pointer","","Looks up a value by a JSON Pointer.",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"pointer_mut","","Looks up a value by a JSON Pointer and returns a mutable reference to that value.",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"option"}}],[11,"deserialize_any","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_option","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_enum","","",0,null],[11,"deserialize_newtype_struct","","",0,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_bool","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i8","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i16","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i32","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_i64","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u8","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u16","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u32","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_u64","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_f32","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_f64","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_char","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_str","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_string","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_bytes","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_byte_buf","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_unit","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_unit_struct","","",0,{"inputs":[{"name":"self"},{"name":"str"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_seq","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_tuple","","",0,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_tuple_struct","","",0,{"inputs":[{"name":"self"},{"name":"str"},{"name":"usize"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_map","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_struct","","",0,null],[11,"deserialize_identifier","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"deserialize_ignored_any","","",0,{"inputs":[{"name":"self"},{"name":"v"}],"output":{"name":"result"}}],[11,"from","","Convert `String` to `Value`",0,{"inputs":[{"name":"string"}],"output":{"name":"value"}}],[11,"from","","Convert 32-bit floating point number to `Value`",0,{"inputs":[{"name":"f32"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"u16"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"i16"}],"output":{"name":"value"}}],[11,"from","","Convert a `Vec` to `Value`",0,{"inputs":[{"name":"vec"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"u8"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"i8"}],"output":{"name":"value"}}],[11,"from","","Convert string slice to `Value`",0,{"inputs":[{"name":"str"}],"output":{"name":"value"}}],[11,"from","","Convert copy-on-write string to `Value`",0,{"inputs":[{"name":"cow"}],"output":{"name":"value"}}],[11,"from","","Convert 64-bit floating point number to `Value`",0,{"inputs":[{"name":"f64"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"i64"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"u64"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"isize"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"i32"}],"output":{"name":"value"}}],[11,"from","","Convert a slice to `Value`",0,null],[11,"from","","",0,{"inputs":[{"name":"usize"}],"output":{"name":"value"}}],[11,"from","","Convert boolean to `Value`",0,{"inputs":[{"name":"bool"}],"output":{"name":"value"}}],[11,"from","","Convert map (with string keys) to `Value`",0,{"inputs":[{"name":"map"}],"output":{"name":"value"}}],[11,"from","","",0,{"inputs":[{"name":"u32"}],"output":{"name":"value"}}],[11,"index_mut","","Write into a `serde_json::Value` using the syntax `value[0] = ...` or `value[\"k\"] = ...`.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"value"}}],[11,"index_mut","","",22,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"value"}}],[11,"index","","",22,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"value"}}],[11,"index","","Index into a `serde_json::Value` using the syntax `value[0]` or `value[\"k\"]`.",0,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"value"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","Display a JSON value as a string.",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"string"}],"output":{"name":"bool"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"i8"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"i16"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"f32"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"isize"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"u64"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"u16"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"f64"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"bool"}}],[11,"into_iter","","",22,null],[11,"serialize","","",22,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"serialize","","",0,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"result"}}],[11,"deserialize","","",22,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"deserialize","","",0,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"value"}}],[11,"default","","",22,{"inputs":[],"output":{"name":"map"}}],[11,"extend","","",22,null],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"map"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"value"}}],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_iter","","Convert an iteratable type to a `Value`",0,{"inputs":[{"name":"i"}],"output":{"name":"value"}}],[11,"from_iter","","",22,{"inputs":[{"name":"t"}],"output":{"name":"map"}}],[11,"new","","Makes a new empty Map.",22,{"inputs":[],"output":{"name":"map"}}],[11,"with_capacity","","Makes a new empty Map with the given initial capacity.",22,{"inputs":[{"name":"usize"}],"output":{"name":"map"}}],[11,"clear","","Clears the map, removing all values.",22,null],[11,"get","","Returns a reference to the value corresponding to the key.",22,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"option"}}],[11,"contains_key","","Returns true if the map contains a value for the specified key.",22,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"bool"}}],[11,"get_mut","","Returns a mutable reference to the value corresponding to the key.",22,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"option"}}],[11,"insert","","Inserts a key-value pair into the map.",22,{"inputs":[{"name":"self"},{"name":"string"},{"name":"value"}],"output":{"name":"option"}}],[11,"remove","","Removes a key from the map, returning the value at the key if the key was previously in the map.",22,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"option"}}],[11,"entry","","Gets the given key's corresponding entry in the map for in-place manipulation.",22,{"inputs":[{"name":"self"},{"name":"s"}],"output":{"name":"entry"}}],[11,"len","","Returns the number of elements in the map.",22,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if the map contains no elements.",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"iter","","Gets an iterator over the entries of the map.",22,{"inputs":[{"name":"self"}],"output":{"name":"iter"}}],[11,"iter_mut","","Gets a mutable iterator over the entries of the map.",22,{"inputs":[{"name":"self"}],"output":{"name":"itermut"}}],[11,"keys","","Gets an iterator over the keys of the map.",22,{"inputs":[{"name":"self"}],"output":{"name":"keys"}}],[11,"values","","Gets an iterator over the values of the map.",22,{"inputs":[{"name":"self"}],"output":{"name":"values"}}]],"paths":[[4,"JsonValue"],[3,"Configuration"],[4,"Error"],[4,"ByteSequence"],[3,"LdapAuthenticator"],[3,"Authorization"],[3,"AuthenticationResult"],[4,"Error"],[3,"NoOp"],[3,"NoOpConfiguration"],[3,"SimpleAuthenticatorConfiguration"],[3,"SimpleAuthenticator"],[8,"Authenticator"],[8,"AuthenticatorConfiguration"],[3,"Configuration"],[3,"RefreshTokenConfiguration"],[3,"Token"],[3,"Keys"],[4,"Error"],[4,"Secret"],[3,"RefreshToken"],[3,"Url"],[3,"JsonMap"]]};
searchIndex["rowdy_diesel"] = {"doc":"Diesel Support for Rowdy","items":[[8,"Connection","rowdy_diesel","Perform connections to a backend.",null,null],[16,"Backend","","The backend this connection represents.",0,null],[10,"establish","","Establishes a new connection to the database at the given URL. The URL should be a valid connection string for a given backend. See the documentation for the specific backend for specifics.",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"transaction","","Executes the given function inside of a database transaction. When a transaction is already occurring, savepoints will be used to emulate a nested transaction.",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"result"}}],[11,"begin_test_transaction","","Creates a transaction that will never be committed. This is useful for tests. Panics if called while inside of a transaction.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"test_transaction","","Executes the given function inside a transaction, but does not commit it. Panics if the given function returns an `Err`.",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"t"}}],[3,"Authenticator","","A generic authenticator backed by a connection to a database via diesel.",null,null],[4,"Error","","Errors from using `rowdy-diesel`.",null,null],[13,"ConnectionError","","A diesel connection error",1,null],[13,"DieselError","","A generic error occuring from Diesel",1,null],[13,"InitializationError","","Error while attempting to initialize a connection pool",1,null],[13,"ConnectionTimeout","","Timeout while attempting to retrieve a connection from the connection pool",1,null],[13,"AuthenticationFailure","","Authentication error",1,null],[13,"InvalidUnicodeInPath","","Invalid Unicode characters in path",1,null],[0,"schema","","Schema of the `users` table that will be used with Rowdy If you have more sophisticated needs, you are able to add more columns to the basic columns needed for rowdy to work.",null,null],[0,"users","rowdy_diesel::schema","Table used to hold users and their hashed passwords",null,null],[3,"star","rowdy_diesel::schema::users","Represents `table_name.*`, which is sometimes needed for efficient count queries. It cannot be used in place of `all_columns`, and has a `SqlType` of `()` to prevent it being used that way",null,null],[3,"username","","Username for the user. Also the primary key",null,null],[3,"hash","","A argon2i hash of the user's password",null,null],[3,"salt","","Salt used to generate the password hash",null,null],[3,"table","","The actual table struct",null,null],[0,"dsl","","Re-exports all of the columns of this table, as well as the table struct renamed to the module name. This is meant to be glob imported for functions which only deal with one table.",null,null],[3,"username","rowdy_diesel::schema::users::dsl","Username for the user. Also the primary key",null,null],[3,"hash","","A argon2i hash of the user's password",null,null],[3,"salt","","Salt used to generate the password hash",null,null],[3,"users","","The actual table struct",null,null],[0,"columns","rowdy_diesel::schema::users","Contains all of the columns of this table",null,null],[3,"star","rowdy_diesel::schema::users::columns","Represents `table_name.*`, which is sometimes needed for efficient count queries. It cannot be used in place of `all_columns`, and has a `SqlType` of `()` to prevent it being used that way",null,null],[3,"username","","Username for the user. Also the primary key",null,null],[3,"hash","","A argon2i hash of the user's password",null,null],[3,"salt","","Salt used to generate the password hash",null,null],[6,"SqlType","rowdy_diesel::schema::users","The SQL type of all of the columns on this table",null,null],[6,"BoxedQuery","","Helper type for representing a boxed query from this table",null,null],[17,"all_columns","","A tuple of all of the columns on this table",null,null],[8,"Migration","rowdy_diesel::schema","Trait to provide idempotent minimal migration to create the table necessary for `rowdy-diesel` to work. If you have more sophisticated needs, you are able to add more columns to the basic columns needed for rowdy to work.",null,null],[16,"Connection","","Connection type for the migration to work with",2,null],[10,"connection","","Provide a connection for the migration to work with",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[10,"migration_query","","Format the migration query based on the connection type",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"migrate","","Provide idempotent minimal migration to create the table necessary for `rowdy-diesel` to work",2,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"mysql","rowdy_diesel","MySQL authenticator module",null,null],[3,"Configuration","rowdy_diesel::mysql","(De)Serializable configuration for MySQL Authenticator. This struct should be included in the base `Configuration`. # Examples `json { \"host\": \"localhost\", \"port\": 3306, \"database\": \"auth_users\", \"user\": \"auth_user\", \"password\": \"password\" }`",null,null],[12,"host","","Host for the MySql database manager - domain name or IP",3,null],[12,"port","","MySql database port - default 3306",3,null],[12,"database","","MySql database",3,null],[12,"user","","MySql user",3,null],[12,"password","","MySql password",3,null],[6,"Authenticator","","A rowdy authenticator that uses a MySQL backed database to provide the users",null,null],[11,"with_uri","","Using a database connection string of the form `mysql://[user[:password]@]host/database_name`, create an authenticator that is backed by a connection pool to a MySQL database",4,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"with_configuration","","Create a new `Authenticator` with a database config",4,{"inputs":[{"name":"str"},{"name":"u16"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":{"name":"result"}}],[11,"connection","","",4,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"migration_query","","",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"make_authenticator","","",3,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"sqlite","rowdy_diesel","SQLite authenticator module",null,null],[3,"Configuration","rowdy_diesel::sqlite","(De)Serializable configuration for SQLite Authenticator. This struct should be included in the base `Configuration`. # Examples `json { \"database\": \"file:/home/fred/data.db\" }`",null,null],[12,"path","","Connect to a SQLite database at a certain path",5,null],[6,"Authenticator","","A rowdy authenticator that uses a SQLite backed database to provide the users",null,null],[11,"with_path","","Connect to a SQLite database at a certain path",6,{"inputs":[{"name":"s"}],"output":{"name":"result"}}],[11,"connection","","",6,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"migration_query","","",6,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"make_authenticator","","",5,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[0,"postgres","rowdy_diesel","PostgresSQL authenticator module",null,null],[3,"Configuration","rowdy_diesel::postgres","(De)Serializable configuration for PostgresSQL Authenticator. This struct should be included in the base `Configuration`. # Examples `json { \"host\": \"localhost\", \"port\": 3306, \"database\": \"auth_users\", \"user\": \"auth_user\", \"password\": \"password\" }`",null,null],[12,"host","","Host for the PostgresSQL database manager - domain name or IP",7,null],[12,"port","","PostgresSQL database port - default 5432",7,null],[12,"database","","PostgresSQL database",7,null],[12,"user","","PostgresSQL user",7,null],[12,"password","","PostgresSQL password",7,null],[6,"Authenticator","","A rowdy authenticator that uses a PostgresSQL backed database to provide the users",null,null],[11,"with_uri","","Using a database connection string of the form `postgresql://[user[:password]@][host][:port][/database_name]`, create an authenticator that is backed by a connection pool to a PostgresSQL database",8,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"with_configuration","","Create a new `Authenticator` with a database config",8,{"inputs":[{"name":"str"},{"name":"u16"},{"name":"str"},{"name":"str"},{"name":"str"}],"output":{"name":"result"}}],[11,"connection","","",8,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"migration_query","","",8,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"configuration"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"make_authenticator","","",7,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"fmt","rowdy_diesel","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",1,{"inputs":[{"name":"connectionerror"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"initializationerror"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"gettimeout"}],"output":{"name":"error"}}],[11,"hash_password","","Hash a password with the salt. See struct level documentation for the algorithm used.",9,null],[11,"verify","","Verify that some user with the provided password exists in the database, and the password is correct.",9,{"inputs":[{"name":"self"},{"name":"str"},{"name":"str"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate","","",9,{"inputs":[{"name":"self"},{"name":"authorization"},{"name":"bool"}],"output":{"name":"result"}}],[11,"authenticate_refresh_token","","",9,{"inputs":[{"name":"self"},{"name":"jsonvalue"}],"output":{"name":"result"}}],[11,"fmt","rowdy_diesel::schema::users","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"star"}}],[11,"walk_ast","","",10,{"inputs":[{"name":"self"},{"name":"astpass"}],"output":{"name":"queryresult"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"username"}}],[11,"walk_ast","","",11,{"inputs":[{"name":"self"},{"name":"astpass"}],"output":{"name":"queryresult"}}],[11,"has_static_query_id","","",11,{"inputs":[],"output":{"name":"bool"}}],[11,"name","","",11,{"inputs":[],"output":{"name":"str"}}],[11,"eq_all","","",11,null],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",12,{"inputs":[{"name":"self"}],"output":{"name":"hash"}}],[11,"walk_ast","","",12,{"inputs":[{"name":"self"},{"name":"astpass"}],"output":{"name":"queryresult"}}],[11,"has_static_query_id","","",12,{"inputs":[],"output":{"name":"bool"}}],[11,"name","","",12,{"inputs":[],"output":{"name":"str"}}],[11,"eq_all","","",12,null],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"salt"}}],[11,"walk_ast","","",13,{"inputs":[{"name":"self"},{"name":"astpass"}],"output":{"name":"queryresult"}}],[11,"has_static_query_id","","",13,{"inputs":[],"output":{"name":"bool"}}],[11,"name","","",13,{"inputs":[],"output":{"name":"str"}}],[11,"eq_all","","",13,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"table"}}],[11,"star","","Represents `table_name.*`, which is sometimes necessary for efficient count queries. It cannot be used in place of `all_columns`",14,{"inputs":[{"name":"self"}],"output":{"name":"star"}}],[11,"from_clause","","",14,null],[11,"default_selection","","",14,null],[11,"as_query","","",14,null],[11,"primary_key","","",14,null],[11,"all_columns","","",14,null],[11,"table","","",14,null],[11,"into_update_target","","",14,{"inputs":[{"name":"self"}],"output":{"name":"updatetarget"}}],[11,"join_target","","",14,null],[11,"join_target","","",14,null],[11,"join_target","","",14,null],[11,"join_target","","",14,null],[11,"has_static_query_id","","",14,{"inputs":[],"output":{"name":"bool"}}]],"paths":[[8,"Connection"],[4,"Error"],[8,"Migration"],[3,"Configuration"],[6,"Authenticator"],[3,"Configuration"],[6,"Authenticator"],[3,"Configuration"],[6,"Authenticator"],[3,"Authenticator"],[3,"star"],[3,"username"],[3,"hash"],[3,"salt"],[3,"table"]]};
initSearch(searchIndex);
